* test.tree is a functional test harness for Clojure.  
    It fulfills the same purpose as Java's TestNG or Python's
    nosetests.  It gathers tests, handles dependencies, allows
    flexible grouping and ordering of tests and their associated
    setups.  It is multithreaded, and leverages Clojure's power as much
    as possible.  Everything is "just plain Clojure" - maps, lists,
    and functions.
** Sampling of supported scenarios:
    + Run many tests in parallel
    + Generate data-driven tests
    + Select, filter, and group tests by name, tag, or your own
       custom function.
    + Apply setup/teardown procedures to any selected tests.
    + Produce junit format xml reports.
    + Use test pre-conditions - skip tests if the precondition fails
    + Get callbacks when tests start/end/pass/fail/skip
    + Control depth of testing
** Example test suite
   #+BEGIN_EXAMPLE
     (def gmail-tests  {:name "log in"
                        :steps (fn [] (login "user" "password"))
                        :more [{:name "send simple email"
                                :steps (fn [] (send-email :from "blah@blah.com" 
                                                          :to "joe@blow.com"
                                                          :subject "stuff")) }
                               {:name "search for email"
                                :steps search/simple
                                :more [{:name "search with boolean"
                                        :steps (fn [] (search "cat or dog"))}]}]})
   #+END_EXAMPLE
*** Items to note
    + *:name* can be any string (actually doesn't even have to be a string,
      but will be printed out later using str).
    + *:steps* are always no arg function, aka 'thunk'.   
    + *:more* is a list of child tests.  
*** Optional keys
    + *:pre* - a precondition function.  If the function returns nil,
      that means the precondition passed, and the test will be run. If
      it returns a value, it should be a list of reasons why the test
      couldn't be run (will be collected later for a report of
      blockages).  These "reasons" can be any type, but again strings
      are probably best.  
    + *:configuration* - if set to logical true, this test is just setup
      or teardown for some other test (usually setup for its
      children). All this does is prevent this test from being
      reported in the results.  However if it throws an exception, it
      will be reported as a test failure, and prevent its children
      from running.
    + *:always-run* - if set to logical true, run this test even if its
      parent did not pass.  It will still be guaranteed to run after
      its parent.  If it passes, its children will be run.  
    + *:description* - a detailed description of the test.  Not
      currently used for anything except to appear in the report.

** How do I use it?
   The requirements for a set of test.tree tests is a little bit
   different than TestNG or nosetests.  Rather than annotating tests
   with information about when they should run, test.tree traverses an
   explicitly arranged tree of tests.  This may sound rigid, but
   Clojure is so good at manipulating these data structures, that it's
   just as flexible as other tools, if not more so.  The test tree
   really only has one important contract - that no child test will be
   run before its parent.  However there are some general guidelines
   that will make writing tests easier:
   + Each expanding level of the tree should be more and more detailed
     testing.  Each node will only be run if its parent passes.
     *Example:* if you were testing the gmail app, logging in would
     probably be at the root of the tree, since not much else can be
     tested if that fails.  A test that sends a simple email is a
     parent, a test that sends an email with an attachment is a child.
     Deleting an email from search results would be a child test of a
     simple search test.
   + Each node is a map - it contains the test's name, a no-arg
     function that when called, runs the actual test, a list of child
     tests, and some optional properties.
   + Each test needs to be *atomic*.  The only guarantee test.tree
     makes about a test is that its parent will have passed before it
     is executed.  If the parent fails, the child and all its
     descendants are marked "skipped" and not run.  There is no
     guarantee that a child will run *immediately* after its parent,
     or that it will run on the same thread.  That means you should
     take precautions to avoid collisions and discontinuity in your
     app.  To go back to the gmail example, if there are 3 sibling
     tests:
  
      1. Forward an email
      2. Reply to an email
      3. Delete an email
       
     They should not all try to operate on the same email!  'Delete'
     may run first.  If a collision is possible, each test should
     either create or check for its own resources as part of its
     procedure.  
** Why do it that way?
*** By arranging the tree by dependency, you get a lot for free.
     + Ability to control depth of testing.  If you have a suite of 1000
       automated tests that take 8 hours to run, but you need to test a
       patch very quickly and only have 1 hour, you just set maxtime to
       1 hour, and test.tree descends as deeply into the tree as it can
       in 1 hour.  That guarantees the most meaningful regression
       testing in the amount of time available.
     + A list of your application's dependencies is maintained just as
       a side effect of having automated tests.  If someone wants to
       know what features need to be working in order to test feature
       X, just look at your tree for the path from the root, to the
       test for feature X.  test.tree will actually just give you this
       information directly as well.
** What about multithreading?
   Multithreaded applications are hard.  But in this case it's worth
   it - Clojure is designed for concurrency, and execution speed of
   functional tests is important.  If you arrange your tests by
   dependency and avoid collisions of resources, then your tests
   should be easily run in parallel.
* 
